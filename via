#!/bin/sh

set -e
set -h
set -o nounset 

source /via/via.conf

chroot=$VIAHOME/chroot
cache=$VIAHOME/cache
plans=$VIAHOME/plans
logs=$VIAHOME/logs
log=$VIAHOME/logs/via.log

builds=$cache/builds
sources=$cache/sources
stages=$cache/stages
packages=$cache/packages

PATH=/tools/bin:$PATH

init() {
	# setup cache dir end log dir
	for d in $logs $builds $sources $stages $packages; do
		if [ ! -d $d ]; then
			log $FUNCNAME $d
			mkdir -p $d
		fi
	done

	export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS CHOST
}

download() {
	local url=$1
	local file=$(basename $url)
	if [ $url = "nil" ]; then
		log $FUNCNAME "no source file"
		return 0
	fi
	_pushd $sources
	if [ ! -f $file ]; then
		log $FUNCNAME $url
		curl -L -# -O $url
		#wget -c $url
	fi	
	_popd
}

# TODO: rework staging to be more flexiable
stage() {
	local file=$1
	local btype=$2
	if [ -z $build_name ]; then
		build_name=$name-$version
	fi
	if [ $file = "nil" ]; then
		log $FUNCNAME "no source file"
		[ ! -d $builds/$build_name ] && mkdir -v $builds/$build_name
		return 0
	fi
	_pushd $stages
		if [ ! -d $build_name ]; then
			tar xf $sources/$file
			if [ -d $plans/$name/patches ]; then
				for i in $plans/$name/patches/*; do
					patch -Np1 $1
				done
			fi
		fi
	_popd
	if [ ! -d $builds/$build_name ] && [ $btype = "gnu_build" ]; then
		mkdir -v $builds/$build_name
	fi
	if [ $btype = "gnu_make" ] || [ $btype = "custom_build" ]; then
		if [ ! -d $builds/$build_name ]; then
			cp -af $stages/$build_name $builds 
		fi
	fi
}

build() {
	source $plans/$1/plan
	local btype=$(echo $build)
	log starting $name
	download $source
	${verify} $source
	log stageing $name
	stage $(basename $source) $btype #&> $log
	_pushd $builds/$build_name
		log $(echo $build) $name
		$pre
		$build #&> $log
		log $(echo $install) $name
		log installing $name
		$install #&> $log
		$post
	_popd
	log finished $name
}

# <action> <details>
log() {
	printf "%-15.15s %s\n" "$1" "$2" | tee -a $log
}

_pushd() {
	#pushd $1 &> /dev/null
	builtin pushd "$@" > /dev/null
}

_popd() {
	popd &> /dev/null
}

confargs="--prefix=/usr"

gnu_build() {
	$stages/$build_name/configure $confargs $build_args
	make
}

no_build() {
	log $FUNCNAME "$name skipping build"
}

gnu_install() {
	make install $install_args
}

gnu_make() {
	echo $PWD
	make $build_args
}

gnu_verify() {
	local url=$1
	local file=$(basename $url)
	log $FUNCNAME $name
	_pushd $sources
		if [ ! -f $file.sig ]; then
			download $url.sig
		fi
		if ! gpg --verify $file.sig; then
			log $FUNCNAME $(red FAILED)
			return 1
		fi	
		log $FUNCNAME $(green PASS)
	_popd
}

no_verify() {
	echo "**** WARNING VERIFICATION IS TURNED OFF for $name ****"
}

sha_verify() {
	local url=$1
	local file=$(basename $url)
	log $FUNCNAME $name
	_pushd $sources
		sha=$(sha256sum $file | awk '{print $1}')
		if [ ! $sha = $verify_args ]; then
			log $FUNCNAME $(red FAILED)
			echo $sha
			return 1
		fi	
		log $FUNCNAME $(green PASS)
	_popd
}

red() {
	local red=$(tput setaf 1)
	local reset=$(tput sgr0)
	echo ${red}$1${reset}
}

green() {
	local green=$(tput setaf 2)
	local reset=$(tput sgr0)
	echo ${green}$1${reset}
}

tail() {
	tail -f $log
}

new() {
	local name=$1
	local version=$2
	log $FUNCNAME $name
	if [ ! -d $plans/$name ]; then
		mkdir $plans/$name
		cp $plans/plan.proto $plans/$name/plan
		sed -i "s:NAME:$name:" $plans/$name/plan
		sed -i "s:VERSION:$version:" $plans/$name/plan
		cat $plans/$name/plan
		return 0
	fi
	log $FUNCNAME $(red "exists already")
}

edit() {
	local name=$1
	$EDITOR $plans/$name/plan
}

strip_tools() {
	strip --strip-debug /tools/lib/*
	strip --strip-unneeded /tools/{,s}bin/*
	rm -rf /tools/{,share}/{info,man}
}

chroot() {
	for i in bin via dev proc sys; do
		if [ ! -d $chroot/$i ]; then
			log create $i
			mkdir $chroot/$i
		fi
	done

	if [ ! -f $chroot/bin/via ]; then
		ln -s /via/via $chroot/bin/via
	fi

	sudo mount -o bind $VIAHOME $chroot/via
	
	sudo chroot "$chroot" /usr/bin/env -i \
		HOME=/via TERM="linux" PS1='\u:\w\$ ' \
		PATH=/bin:/usr/bin:/sbin:/usr/sbin \
		/bin/bash --login +h
	sudo umount $chroot/via
}

umount_all() {
	sudo umount $chroot/via
}

back_trace() {
	cat $log
}

#trap back_trace ERR
init
action=$1 
shift
$action $@
