#! /bin/bash
# ex: ts=8 sw=4 sts=4 et filetype=sh

if [ -n "$DEBUG" ]; then
    set -x
fi

set -e
set -h
set -u

VIAHOME=/home/strings/github/via

#ROOT=$VIAHOME/test
#ROOT=$VIAHOME/root
ROOT=/

TEST=""

PREFIX="/usr"

CARCH="x86_64"
CHOST="x86_64-unknown-linux-gnu"


# -march : cpu to build for
# -mtune : generic optimization for -march
# -O2    : optimization level for code
# -pipe  : use pipes instead of tmp files for compiler communication
CFLAGS="-march=native -mtune=native -O2 -pipe"
CXXFLAGS="-march=native -mtune=native -O2 -pipe"

# --hash-style : use gnu hash tables
# --as-needed  : only add libraries to DT_NEEDED that resolve 
LDFLAGS="-Wl,--hash-style=gnu -Wl,--as-needed"
MAKEFLAGS="-j3"

GPG_USER="test@test.com"

chroot=$VIAHOME/chroot
repo=$VIAHOME/repo
cache=$VIAHOME/cache
plans=$VIAHOME/plans
logs=$VIAHOME/logs
log=$VIAHOME/logs/via.log

builds=$cache/builds
sources=$cache/sources
stages=$cache/stages
packages=$cache/packages

init() {
    # setup cache dir end log dir
    for d in $logs $repo $builds $sources $stages $packages; do
        if [ ! -d $d ]; then
            log $FUNCNAME $d
            mkdir -p $d
        fi
    done

    export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS CHOST
}


# function download()
# downloads a url
# $1 = url
# example:
# download http://www.foo.org/foo.tar.gz
download() {
    if [ "$source" == "NIL" ]; then
        echo "RETURN"
        return
    fi

    local url="$1"
    local file="$(basename $url)"

    if [ "$url" = "nil" ]; then
        log "$FUNCNAME" "no source file"
        return 0
    fi
    _pushd "$sources"
    if [ ! -f "$file" ]; then
        log "$FUNCNAME" "$url"
        curl -L -# -O "$url"
    fi	
    _popd

}

# FIXME: this whole function is a mess rework it properly
via_stage() {
    source_plan $1
    local file="$(basename $source)"
    local btype="$(echo $builder)"

    log "$FUNCNAME" "$name"

    if [ "$file" = "NIL" ]; then
        log "$FUNCNAME" "no source file"
        [ ! -d "$builds/$build_name" ] && mkdir "$builds/$build_name"
        [ ! -d "$stages/$build_name" ] && mkdir $stages/$build_name
        return 0
    fi
    _pushd "$stages"
    if [ ! -d "$build_name" ]; then
        tar xf "$sources/$file"
        if [ -d "$plan_dir/patches" ]; then
            _pushd "$build_name"
            for i in $plan_dir/patches/*; do
                log "applying" "$(basename $i)"
                patch -Np1 -i "$i"
            done
            _popd
        fi
    fi
    _popd
    _pushd $stages/$build_name
        btype=$(get_build_type)
    _popd $stages/$build_name
    if [ ! -d "$builds/$build_name" ] && [ "$btype" = "gnu_build" ]; then
        mkdir "$builds/$build_name"
    fi

    if [ ! "$btype" = "gnu_build" ] && [ ! -d "$builds/$build_name" ]; then
        cp -af "$stages/$build_name" "$builds"
    fi
}

via_build_core() {
    if [ "$ROOT" = "/" ]; then
        log "ERROR" "ROOT is set to / this is wrong!"
        log "ERROR" "specify target dir with -r"
        exit 1
    fi
    local db=$ROOT/var/db/via
    for i in $plans/core/*; do
        source_plan "$(basename $i)"
        if [ ! -d "$db/$name-$version" ] ; then
            via build "$name"
            via -r $ROOT install "$name"
        else
            log skipping $name
        fi
    done
}

via_build_install() {
    via_build $1
    sudo -E via install "$1"
}

source_plan() {
    source $plans/*/$1/plan

    source="${source:-NIL}"
    builder="${builder:-NIL}"
    packager="${packager:-NIL}"

    plan_dir=$(echo $plans/*/$1)
    files_dir="$plan_dir/files"

    if [ "${build_name:-NIL}" = "NIL" ]; then
        build_name=$name-$version
    fi

    if [ "${build_args:-NIL}" = "NIL" ]; then
        build_args=""
    fi

    export DESTDIR="$packages/$name-$version"

    if [ "${package_args:-NIL}" = "NIL" ]; then
        package_args=""
    fi
}

get_build_type() {
    # if builder is set use it.
    if [ "$builder" != "NIL" ]; then
        printf "$builder"
        return 0
    fi
    # check for configure if it exists set gnu_build
    if [ -f "configure" ]; then
        printf "gnu_build"
        return 0
    fi

    if [ -f "Makefile" ]; then
        printf "gnu_make"
        return 0
    fi

    if [ -f "setup.py" ]; then
        printf "python_build"
        return 0
    fi

    echo "ERROR" "could not determine builder type"
    exit 1
}

get_package_type() {
    # if packager is set use it.
    if [ "$packager" != "NIL" ]; then
        printf "$packager"
        return 0
    fi
    # check for configure if it exists set gnu_build
    if [ -f "configure" ]; then
        printf "gnu_package"
        return 0
    fi

    if [ -f "Makefile" ]; then
        printf "gnu_package"
        return 0
    fi

    if [ -f "setup.py" ]; then
        printf "python_package"
        return 0
    fi

    log "ERROR" "could not determine packager type"
    exit 1
}

via_build() {
    source_plan $1
    log starting $name
    download $source
    case $verify in
        gnu_verify)
            gnu_verify $source
            ;;
        sign_verify)
            sign_verify $source
            ;;
        no_verify)
            ;;
        *)
            sha_verify $source
            ;;
    esac

    via_stage $name

    _pushd "$stages/$build_name"
        builder=$(get_build_type)
        build_type=$(echo $builder)
        packager=$(get_package_type)
    _popd

    _pushd $builds/$build_name
        log "$build_type" "$name"
        $builder #&>> $log
        if [ "$build_type" = "gnu_build" ] && [ -n "$TEST" ]; then
            make check
        fi
        via_package $name
    _popd

    log done "$name-$version"
}

via_package() {
    source_plan "$1"
    local pkgfile=$repo/$name-$version-via.tar.gz
    log $FUNCNAME "$name"
    if [ -d $DESTDIR ]; then
        log "cleaning" "$DESTDIR"
        rm -rf $DESTDIR
    fi
    log $(echo $packager) $name
    _pushd $builds/$build_name
        $packager #&>> $log
    _popd
    package_files_dir
    if [ ! -d $DESTDIR ]; then
        mkdir $DESTDIR
    fi
    if [ -n "${CLFS_TARGET:-}" ]; then
        _pushd $DESTDIR/tools
    else
        _pushd $DESTDIR/tools
    fi
    if [ "$(type -t post_hook)" = "function" ]; then
        post_hook
    fi
    find . > MANIFEST
    log "compressing" $pkgfile
    fakeroot tar cfz $pkgfile *
    _popd
    _pushd $repo
    pkgfile=$name-$version-via.tar.gz
    log "signing" $pkgfile
    [ -f $pkgfile.sig ] && rm $pkgfile.sig
    gpg -u $GPG_USER --detach-sign $pkgfile
    log $pkgfile $(green "OK")
    gpg --verify $pkgfile.sig 
    _popd
}

package_files_dir() {
    if [ ! -d $files_dir ]; then
        return
    fi
    for f in $files_dir/*; do
        local file=$(head -1 < $f | awk '{print $2}')
        local mode=$(head -1 < $f | awk '{print $3}')
        log "installing" "$file"
        fakeroot install -Dm $mode $f $DESTDIR/$file
    done
}

install_core() {
    via -r $ROOT install filesystem
    for i in $plans/core/*; do
        via -r $ROOT install "$(basename $i)"
    done
    cp /etc/ld.so.conf $ROOT/etc
    cp /etc/nsswitch.conf $ROOT/etc
    ldconfig -r $ROOT
    chroot $ROOT groupadd -g 81 dbus
    chroot $ROOT useradd -u 81 -g dbus -d / -s /bin/false dbus
    chroot $ROOT passwd -l dbus
    chroot $ROOT dbus-uuidgen --ensure
    chroot $ROOT groupadd -g 54 lock
    chroot $ROOT systemd-machine-id-setup
    log "core" "installed"
}

diff_manifest() {
    local fullname=$name-$version
    local pkgfile=$repo/$fullname-via.tar.gz
    local db=var/db/via
    while read line; do
        case "${line::1}" in
            "<")
                echo $(red "$line")
                ;;
            ">")
                echo $(green "$line")
                ;;
            *)
                echo "$line"
        esac
    done < <(diff $db/$fullname/MANIFEST <(tar xOf $pkgfile MANIFEST))
}

via_install() {
    source_plan $1
    local fullname=$name-$version
    local pkgfile=$repo/$fullname-via.tar.gz
    local db=var/db/via

    [ -d $ROOT ] || mkdir -p $ROOT

    gpg --verify $pkgfile.sig
    _pushd $ROOT
    [ -d $db ] || mkdir -p $db
    if [ -f MANIFEST ]; then
        log $FUNCNAME "$(red "ERROR") $fullname: MANIFEST exists"
        return 1
    fi
    if [ -d "$db/$fullname" ]; then
        diff_manifest
        log $(yellow WARNING) "$fullname is already installed"
        echo -n "reinstall ? y/n "
        read ok
        if [ "$ok" = "N" ] || [ -z "$ok" ] || [ "$ok" != "y" ]; then
            echo "not installing"
            return 0
        fi
        via_remove $1
    fi
    log "installing" $(basename $pkgfile)
    mkdir -p "$db/$fullname"
    tar -xf $pkgfile | true
    mv MANIFEST $db/$fullname/MANIFEST
    _popd
    if [[ $EUID = 0 ]]; then
        ldconfig &> /dev/null
    fi
}

via_remove() {
    local db=var/db/via
    _pushd $ROOT
    local package=$(basename $db/$1-[0-9]*/)
    log "removing" $package
    local manifest=$db/$package/MANIFEST
    # remove files
    while read file; do
        if [ -f $file ]; then
            rm $file
        fi
    done < $manifest
    rm -r $db/$package
    _popd
    log $package "removed"
}

# <action> <details>
log() {
    local blue=$(tput setaf 4)
    local reset=$(tput sgr0)
    printf "${blue}via: ${reset}%-20.20s %s\n" "$1" "$2"
}

_pushd() {
    builtin pushd "$@" > /dev/null
}

_popd() {
    builtin popd &> /dev/null
}

# BUILD HOOKS
confargs="--prefix=$PREFIX --sysconfdir=/etc --enable-shared \
--localstatedir=/var --with-shared"

relocate_build() {
    gnu_build
}

gnu_build() {
    $stages/$build_name/configure $confargs $build_args
    make
}

no_build() {
    log $FUNCNAME "$name"
}

gnu_package() {
    fakeroot make $package_args DESTDIR=$DESTDIR install
}

no_install() {
    log $FUNCNAME "$name"
}

gnu_make() {
    make $build_args
}

no_verify() {
    log $FUNCNAME "no file to verify"
}

python_build() {
    python setup.py build
}

python_package() {
    python setup.py install --root="$DESTDIR/" --optimize=2
}

# VERIFY HOOKS
gnu_verify() {
    local url=$1
    local ext=${2:-sig}
    local file=$(basename $url)
    log $FUNCNAME $name
    _pushd $sources
    if [ ! -f $file.$ext ]; then
        download $url.$ext
    fi
    if ! gpg --verify $file.$ext; then
        log $FUNCNAME $(red FAILED)
        return 1
    fi	
    log $FUNCNAME $(green PASS)
    _popd
}

sign_verify() {
    gnu_verify $1 sign
}

sha_verify() {
    local url=$1
    local file=$(basename $url)
    log $FUNCNAME $name
    _pushd $sources
    sha=$(sha256sum $file | awk '{print $1}')
    if [ ! "$sha" = "$verify" ]; then
        log $FUNCNAME $(red FAILED)
        echo $sha
        return 1
    fi	
    log $FUNCNAME $(green PASS)
    _popd
}
# END HOOKS


red() {
    local red=$(tput setaf 1)
    local reset= #$(tput sgr0)
    echo ${red}$1${reset}
}

green() {
    local green=$(tput setaf 2)
    local reset=$(tput sgr0)
    echo ${green}$1${reset}
}

yellow() {
    local yellow=$(tput setaf 3)
    local reset=$(tput sgr0)
    echo "${yellow}${1}${reset}"
}

blue() {
    local blue=$(tput setaf 4)
    local reset=$(tput sgr0)
    echo ${blue}$1${reset}
}

via_edit() {
    local name=$1
    $EDITOR $plans/*/$name/plan
}

via_mkvirt() {
    local image=./vanilla.img
    local target=./vanilla
    trap "umount $target" ERR
    [ ! -d $target ] && mkdir $target
    ROOT=$target
    qemu-img create -f raw $image 700M
    mkfs.ext4 -F $image
    mount -o loop $image $target
    install_core
    echo "/dev/sda / ext4 defaults 1 2" > $ROOT/etc/fstab
    echo "vanvirt" > $ROOT/etc/hostname
    mount -o bind /dev $target/dev
    chroot $target passwd
    umount $target/dev
    umount $target
    log $FUNCNAME "completed"
}

via_virt() {
    local kernel=/boot/vmlinuz-*
    local initrd=/boot/initramfs-*.img
    echo "starting emulator"
    qemu-system-x86_64 -hda ./vanilla.img \
        -initrd $initrd \
        -kernel $kernel \
        -nographic -append "console=ttyS0 root=/dev/sda init=/bin/systemd"
    #-append "root=/dev/sda"
}

via_import() {
    local abs=/var/abs/
    local target=$1
    local path=$(find $abs -type d -name $target)
    if [ -d $plans/*/$target ]; then
        log $FUNCNAME "$target already exists"
        return 1
    fi
    if [ -z $path ]; then
        log $FUNCNAME "$1 abs not found"
        return
    fi
    source $path/PKGBUILD
    source=${source/$pkgver/\$version}
    local t=$plans/incoming/$target/plan
    mkdir -p $plans/incoming/$target
    cp -v $plans/plan.proto $t
    sed -i "s,NAME,$pkgname," $t
    sed -i "s,VERSION,$pkgver," $t
    sed -i "s,SOURCE,$source," $t
    via_gen_hash $target
    cat $path/PKGBUILD
    log $FUNCNAME "$target imported"
    via build_install $target
}

via_list() {
    local db=/var/db/via
    cat $db/$1-*/MANIFEST
}

via_gen_hash() {
    source_plan $1
    download $source
    local plan=$plans/*/$1/plan
    local file=$(basename $source)
    sha=$(sha256sum $sources/$file | awk '{print $1}')
    echo verify=\"$sha\" >> $plan
}

via_remove_plan() {
    rm -rv $(find $plans -name $1)
}

via_cross_build() {
    TARGET_ARCH="arm"
    ABI="gnueabi"
    unset CHOST CARCH CFLAGS CXXFLAGS
    CLFS_HOST="$(arch)-cross-linux-gnu"
    CLFS_TARGET="${TARGET_ARCH}-linux-${ABI}"
    PREFIX=/tools
    export PATH=/usr/lib/ccache/bin:/cross-tools/bin:/bin:/usr/bin

    export CC="${CLFS_TARGET}-gcc"
    export CXX="${CLFS_TARGET}-g++"
    export AR="${CLFS_TARGET}-ar"
    export AS="${CLFS_TARGET}-as"
    export RANLIB="${CLFS_TARGET}-ranlib"
    export LD="${CLFS_TARGET}-ld"
    export STRIP="${CLFS_TARGET}-strip"

   confargs+="\
	--prefix=$PREFIX \
	--build=${CLFS_HOST} \
	--host=${CLFS_TARGET} \
	--cache-file=config.cache"
    via_build $1
}

while getopts ":r:" opt; do
    case $opt in
        r)
            ROOT=$OPTARG
            shift 2
            ;;
        \?)
            ;;
        :)
            ;;
    esac
done

init
action=$1
shift
via_$action $@
